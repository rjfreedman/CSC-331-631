<!DOCTYPE html>
<html lang = "en">
<head>
  <title> DEAC Cluster System Monitor </title>
  <!-- charset allows bootstrap characters -->
  <meta charset = "utf-8">
  <!-- viewport should allow bootstrap to resize for viewing device -->
  <meta name = "viewport" content = "width = device-width, initial-scale =1">
  <!-- Getting the bootstrap libraries for CSS from a CDN-->
  <!-- KR: Getting the bootstrap libraries for CSS from a CDN-->
  <!-- KR: add bootstrap for CSS, jquery and JavaScript -->
  <!-- 1) bootstrap for CSS: necessary for containers to provide responsive design -->
  <!-- 2,3) jquery and bootstrap for js, necessary for expansion buttons -->
  <link rel = "stylesheet" href = "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

  <!-- KG: needs these bootstrap and style for drop down menu check box functionality -->
  <link href="https://cdn-na.infragistics.com/igniteui/2016.2/latest/css/themes/infragistics/infragistics.theme.css" rel="stylesheet" />
    <link href="https://cdn-na.infragistics.com/igniteui/2016.2/latest/css/structure/infragistics.css" rel="stylesheet" />
    <!-- KR: modernizr allows it to run on old systems like IE7 -->
    <script src="https://ajax.aspnetcdn.com/ajax/modernizr/modernizr-2.8.3.js"></script>
    <!-- KR: removing this jquery because I needed 3.1.1 earlier
    <script src="https://code.jquery.com/jquery-1.11.3.min.js"></script> -->
    <script src="https://code.jquery.com/ui/1.11.1/jquery-ui.min.js"></script>

    <!-- KG: Ignite UI Required Combined JavaScript Files -->
    <script src="https://cdn-na.infragistics.com/igniteui/2016.2/latest/js/infragistics.core.js"></script>
    <script src="https://cdn-na.infragistics.com/igniteui/2016.2/latest/js/infragistics.lob.js"></script>

    <style>
            .combo-label {margin-bottom:.5em; align-items:right; }
    </style>
    <!-- Lee's table style currently styling ALL tables on page -->
    <!-- Riana added the text-align: center specification when populating the data for readability -->
    <style>
            table, tr, th{
                border: 1px solid black;
                border-collapse: collapse;
                text-align: center;
            }
            tr, th{
                padding: 5px
            }
        </style>


</head>
<body>
  <!-- adding containers to ensure the page resizes well on different devices -->
<div class="container-fluid">
  <div class = "row">
    <!-- KR: This is the top of the page, small container at each side for logo/update info, large box in middle for title -->
    <div class="col-sm-2"><p id="logo">logo?</p> </div>
    <div class="col-sm-8"><h1 id="pageTitle" align="center">DEAC Cluster System Monitor</h1></div>
    <div class="col-sm-2">
      <!-- KR: divs for current time and last update time JS fills current, need to add last update time functionality-->
      <p id="currentDateTime"></p>
      <script>
	document.getElementById("currentDateTime").innerHTML=Date()
      </script>
      <p id="lastUpdateDateTime">Site last updated: </p>
      <button class="btn" onclick="refresh()">Refresh</button><br><br> <!-- Added by Riana for refreshing purposes (per discussion with Dr. Pauca). -->
    </div>
  </div>

  <div class="row" id="initialView">
    <!-- KR: All columns equal, change col-sm-* to change this, all must add to 12 -->
    <!-- KR: Currently all containers in this row (3) set to align="center" change as appropriate later. -->
    <div class="col-sm-4" id="clusterStatusFirstView" align="center">
      <!-- KR: put clusterStatusInfographis in the following <figure></figure> -->
      <figure id="clusterStatusInfographic"></figure>
      <!-- KR: collapsible button to expand statusTable div -->
      <button class="btn btn-primary" data-toggle="collapse" data-target="#statusTable">
	More Cluster Status Information
      </button>
    </div>
  <div class="col-sm-4" id="clusterHealthFirstView" align="center">
    <!-- KR: put clusterHealthInfographic in the following <figure></figure> -->
    <figure id="clusterHealthInfographic"></figure>
    <!-- KR: collapsible button to expand healthTable div -->
    <button class="btn btn-primary" data-toggle="collapse" data-target="#healthTable" aria-expanded="false" aria-controls="healthTable">
      More Cluster Health Information
    </button>
  </div>

  <div class="col-sm-4" id="perChassisAccessPoint" align="center">
    <!-- KR: collapsible button to expand healthTable div -->
    <button class="btn btn-primary" data-toggle="collapse" data-target="#chassisInfo" aria-expanded="false" aria-controls="chassisInfo">
      Detailed Information for Each Chassis
    </button>
  </div>
</div> <!-- end 3 column responsive row -->

<!-- KR: following divs must have class="Collapse" so that collapse buttons work -->
<div class="collapse" id="statusTable">
  <!-- Status Table by Lee -->
  <!-- KR: br adds vertical space before the table, play with these to achieve optimal spacing -->
  <br></br>
  <br></br>
  <table id="overall_status_table">
    <h4 class="combo-label">Overall Cluster Status</h4>
    <tr id="overall_status_table_HEADERS">
      <!-- <th>Running Jobs</th>
      <th>Queued Jobs</th>
      <th>Number of CPUs</th> -->
    </tr>
  </table>
</div>

<div class="collapse" id="healthTable">
  <br></br>
  <br></br>
<!-- Health Status Table by AA -->
	<table id="health_table">
	  <h4 class="combo-label">Cluster Health Status</h4>
		<tr id= "health_table_HEADERS">
			<!-- <th>Number of Nodes Up</th>
			<th>Number of Nodes Down</th>
			<th>Number of Nodes Under Maintenance</th> -->
		</tr>

	</table>

</div>
<!-- KG: Chassis Information table and drop down -->
<div class="collapse" id="chassisInfo">
  <br></br>
        <br></br>
    <h4 class="combo-label">Single/Multiple Selection of Chasses with Checkboxes</h4>
    <div id="checkboxSelectCombo" ></div>
    <script type="text/javascript">
        var chasiss = [
            { Name: "Chassis 1" },
            { Name: "Chassis 2" },
            { Name: "Chassis 3" },
            { Name: "Chassis 4" }
        ];
        $(function () {
            $("#checkboxSelectCombo").igCombo({
                width: "270px",
                dataSource: chasiss,
                textKey: "Name",
                valueKey: "Name",
                multiSelection: {
                    enabled: true,
                    showCheckboxes: true
                }
            });
        });
    </script>

  <!--Riana: I fixed the spelling on chassis in the table id and added an id for the headers so they can be autopopulated from the CSV file -->
  <table id="per_chassis_detailed_information_table">
                <tr id="per_chassis_detailed_information_table_HEADERS">
                    <!-- <th>Chassis</th>
                    <th>Utilization</th>
                    <th>Number of CPUs Available</th>
                    <th>Total Number of CPUs</th>
                    <th>Memory Utilization</th> -->
                </tr>
            </table>
</div> <!-- end chassisInfo div -->


</body>
</html>

<!-- start Riana's code -->

<script>

//initiliaze
// var INIT = 0;
// if(INIT === 0)
// {
//   INIT = 1;
//   //read in initial data file and set var prevFileIDs...
// }

  // Read in the file...
  // Resource used to assist:
  // http://stackoverflow.com/questions/27522979/read-a-local-text-file-using-javascript?noredirect=1&lq=1

  // Note: This works for a static filename/local location...

// THE FOLLOWING TOGGLE-COMMENTED OUT CODE WAS SIMPLY MOVED LOWER DOWN IN THE CODE...

//   // Declare a variable to hold the contents of the CSV file in...
//   var csvFile;
//
//   //For now, store the static path to the CSV file in a variable...
//   //This may be adjusted to support the location of the file on the server...
//   //__dirname = path.resolve();
//   //var filePath = "file://" + __dirname + "/overallClusterInfo.csv"; // Note: Will need to add the file path here once it is set...this has been tested with a local file path...
// //console.log(filePath);
//   // Use XMLHttpRequest to read the contents of the data file and store them in variable csvFile.
//   var contents = new XMLHttpRequest();
//   //contents.open("GET", filePath, false);
//   contents.open("GET", "overallClusterInfo.csv", false);
//   contents.onreadystatechange = function ()
//   {
//      if(contents.readyState === 4 && (contents.status === 200 || contents.status == 0))
//      {
//              csvFile = contents.responseText;
//      }
//   }
//   contents.send(null);
//
//   // Parse the data file by rows (newline character-delimited)...
//   // Store each row in an element of rows.
//   var rows = csvFile.split("\n");
//
//   //Check if the file was refreshed by seeing if the value of the entire first row of the table is the same as in this file or not...
//   //Note that this line is a time stamp that is unique...
//   //initiliaze the prevFileID to that of the first file upload...
//   var prevFileID = rows[0]; //call this outside the function that checks if a new function and pass it in...return currentFileID
//
//   var currentFileID = rows[0];
//
//   //ERROR CHECK...
//   console.log(currentFileID);
//
//   if(currentFileID === prevFileID)
//   {
//     console.log("the data file has NOT been refreshed")
//   }
//   else {
//     console.log("the data file HAS been refreshed")
//     //update the data stamp at the top right of the page
//     //in later iterations, store the new file to the database (for backlog story on storing historical data)
//   }
//
//
//   //ERROR CHECK...
//   console.log(rows[2]);
//   console.log(rows.length);

  //Place all code for populating a data file from a header in a function
  //to avoid duplication of code...
  function populateTableFromCSVFile(rowsRead, headerID, rowID)
  {
    // Iterate through each column in the table and insert the values of the row in
    // that element...
    // Skip the first row as it is the unique ID associated with the file to check if file was refreshed.
      // ***Note that it will be important to populate the headers of the table from the file
    // as well in order to allow for the data file/data population to be dynamic.***

    //Initialize to invalid values...
    var indexNodesUP = -1;
    var indexNodesDOWN = -1;
    var indexNodesUNDERMAINTENANCE = -1;
    var numberOfNodesUP = 0;
    var numberOfNodesDOWN = 0;
    var numberOfNodesUNDERMAINTENANCE = 0;

    //Populate the table.
    for(var r = 1; r < rowsRead.length-1; r++)
    {
      //Populate the headers...
      if(r === 1)
      {
        //Dynamically insert the headers for the table according to the data file...
        // Parse this comma-delimited row...
        var headerRow = rowsRead[r].split(",");
        console.log(headerRow);
        for(var c = 0; c < headerRow.length; c++)
        {
          // Add element e to the current row in column c.
          var newHeader = document.createElement("TH");
          var newHeaderContent = document.createTextNode(headerRow[c]);
          newHeader.appendChild(newHeaderContent);
          document.getElementById(headerID).appendChild(newHeader);


          //IF this is the Per Chassis info - gather data for the Cluster Health Status table dynamically...
          //MUST use [STRING].includes("String to compare against") here since white space will affect the result...
          if(headerID === "per_chassis_detailed_information_table_HEADERS")
          {
            if(headerRow[c].includes("Number of Nodes UP"))
            {
              //add this header to a JSON object (which can later be output to a CSV file)...
              indexNodesUP = c;
            }
            else if(headerRow[c].includes("Number of Nodes DOWN"))
            {
              //add this header to a JSON object (which can later be output to a CSV file)...

              indexNodesDOWN = c;
            }
            else if(headerRow[c].includes("Number of Nodes UNDER MAINTENANCE"))
            {
              //add this header to a JSON object (which can later be output to a CSV file)...
              indexNodesUNDERMAINTENANCE = c;
              //console.log("UM:" + indexNodesUNDERMAINTENANCE); //error check...
            }
          }
        }
      }
      //Populate the non-header rows of the table...
      else {
        console.log("HERE");
        // Add a row to the table.
        var newRow = rowID.insertRow(r-1); //important: must index as r-1 since line 1 of file is line 0 in table, line 2 of file is line 1 of table, etc.

        // Parse this comma-delimited row...
        var thisRow = rowsRead[r].split(",");

        //ERROR CHECK...
        console.log(thisRow);

        // Populate the newly created row...
        // ***Note that (in a later iteration), the size of the table will need
        // to potentially dynamically change to accommodate the longest data entry.***
        for(var c = 0; c < thisRow.length; c++)
        {
          // Add element e to the current row in column c.
          var cell = newRow.insertCell(c);
          //cell.style.border = "initial"; //trying to add column delimiters in table
          cell.innerHTML = thisRow[c];

          if(headerID === "per_chassis_detailed_information_table_HEADERS")
          {
            if(c === indexNodesUP)
            {
              numberOfNodesUP += parseInt(thisRow[c]);
            }
            if(c === indexNodesDOWN)
            {
              //console.log("DOWN"); //error check
              numberOfNodesDOWN += parseInt(thisRow[c]);
            }
            if(c === indexNodesUNDERMAINTENANCE)
            {
              //console.log("UM"); //error check
              numberOfNodesUNDERMAINTENANCE += parseInt(thisRow[c]);
            }
          }

        }
      }
    }

    //IF this is the Per Chassis info - gather data for the Cluster Health Status table dynamically...
    if(headerID === "per_chassis_detailed_information_table_HEADERS")
    {
      //Create an empty JSON object...
      if(indexNodesUP === -1) {
        numberOfNodesUP = "ERROR";
      }
      if(indexNodesDOWN === -1) {
        numberOfNodesDOWN = "ERROR";
      }
      if(indexNodesUNDERMAINTENANCE === -1) {
        numberOfNodesUNDERMAINTENANCE = "ERROR";
      }

      var jsonDerivedClusterHealth = {
        "Number of Nodes UP": numberOfNodesUP,
        "Number of Nodes DOWN": numberOfNodesDOWN,
        "Number of Nodes UNDER MAINTENANCE": numberOfNodesUNDERMAINTENANCE
      };

      //return jsonDerivedClusterHealth;
      //Call the function to populate the Cluster Health Status table:
      populateHealthStatusTable(jsonDerivedClusterHealth);
    }
    //else { //do nothing...
      //return "NO CLUSTER HEALTH DATA IS DERIVED FROM THIS FILE.";
    //}
  }


  function readAndStoreData(fileName, idTableHeaders, idTableRows)
  {
    // Declare a variable to hold the contents of the CSV file in...
    var csvFile;

    //For now, store the static path to the CSV file in a variable...
    // Use XMLHttpRequest to read the contents of the data file and store them in variable csvFile.
    var contents = new XMLHttpRequest();
    contents.open("GET", fileName, false);
    contents.onreadystatechange = function ()
    {
       if(contents.readyState === 4 && (contents.status === 200 || contents.status == 0))
       {
               csvFile = contents.responseText;
       }
    }
    contents.send(null);

    // Parse the data file by rows (newline character-delimited)...
    // Store each row in an element of rows.
    var rows = csvFile.split("\n");

    //Check if the file was refreshed by seeing if the value of the entire first row of the table is the same as in this file or not...
    //Note that this line is a time stamp that is unique...
    //initiliaze the prevFileID to that of the first file upload...
    if(init === 0)
    {
      var prevFileID = rows[0]; //call this outside the function that checks if a new function and pass it in...return currentFileID
      init = 1;
      document.getElementById("lastUpdateDateTime").innerHTML = "Site last updated: " + prevFileID;
    }

    var currentFileID = rows[0];

    //ERROR CHECK...
    console.log(currentFileID);

    if(currentFileID === prevFileID)
    {
      console.log("the data file has NOT been refreshed")
    }
    else {
      console.log("the data file HAS been refreshed")
      document.getElementById("lastUpdateDateTime").innerHTML = "Site last updated: " + currentFileID;
      //update the data stamp at the top right of the page
      //in later iterations, store the new file to the database (for backlog story on storing historical data)
    }

    //Call a callback function (of sorts)...
    populateTableFromCSVFile(rows, idTableHeaders, idTableRows);
  }

  function populateHealthStatusTable(derivedClusterHealthStatus)
  {
    //Populate the Cluster Health Status table...
    // Access the HTML table to be updated with this data.
    var healthTable = document.getElementById("health_table");

    //Populate the headers.
    for(var c = 0; c < Object.keys(derivedClusterHealthStatus).length; c++)
    {
      // Add element e to the current row in column c.
      var newHeader = document.createElement("TH");
      var newHeaderContent = document.createTextNode(Object.keys(derivedClusterHealthStatus)[c]);
      newHeader.appendChild(newHeaderContent);
      document.getElementById("health_table_HEADERS").appendChild(newHeader);
    }

    //Populate the rows.
    console.log("WORKING ON HEALTH TABLE...");
    // Add a row to the table.
    //Reminder to self:If can add more rows in this table dynamically, then NEED to change insertRow(1) to insertRow(r) or (r-1)...
    var newRow = healthTable.insertRow(1); //important: must index as r-1 since line 1 of file is line 0 in table, line 2 of file is line 1 of table, etc.

    // Populate the newly created row...
    // ***Note that (in a later iteration), the size of the table will need
    // to potentially dynamically change to accommodate the longest data entry.***
    for(var c = 0; c < Object.keys(derivedClusterHealthStatus).length; c++)
    {
      // Add element e to the current row in column c.
      var cell = newRow.insertCell(c);
      //cell.style.border = "initial"; //trying to add column delimiters in table
      cell.innerHTML = derivedClusterHealthStatus[Object.keys(derivedClusterHealthStatus)[c]];
    }
  }

  ////////////////////////////////////////
  ////////////////////////////////////////

  function clearTable(table, tableHeaders) {

  //  table.innerHTML = "";

    // //Delete headers...
    // deleteTHead();

    var numRows = table.getElementsByTagName("tr").length;

    //deletes each row from the bottom up until the top, leaves row 0, our header row
    for(i = numRows - 1; i > 0; i--){
      table.deleteRow(i);
    }

    var numHeaders = tableHeaders.getElementsByTagName("TH").length;

    //deletes each row from the bottom up until the top, leaves row 0, our header row
    for(i = numHeaders - 1; i >= 0; i--){
      tableHeaders.deleteCell(i);
    }


    //Call these here to avoid a race condition...
  //
  //   //Populate the Overall Cluster Status table...
  //   // Access the HTML table to be updated with this data.
  //   readAndStoreData("overallClusterInfo.csv", "overall_status_table_HEADERS", overallStatusTable);
  //
  // ////////////////////////////////////////
  // ////////////////////////////////////////
  //
  //   //Populate the Per Chassis Info table...
  //   // Access the HTML table to be updated with this data.
  //   readAndStoreData("perChassisInfo.csv", "per_chassis_detailed_information_table_HEADERS", perChassisTable);
  //   //var derivedClusterHealthStatus = populateTableFromCSVFile("per_chassis_detailed_information_table_HEADERS", perChassisTable);
  //   //Cluster Health Status data is derived from the per chassis data and is stored in a JSON object...
    //AND the health status table is populated when the chassis detailed information is complete...
  }


  function refresh()
  {
    var overallStatusTable = document.getElementById("overall_status_table");
    var perChassisTable = document.getElementById("per_chassis_detailed_information_table");

    //FIRST - clear the tables to be sure the refreshed data is NOT accidentally appended to the existing table...
    clearTable(overallStatusTable, document.getElementById("overall_status_table_HEADERS"));
    clearTable(perChassisTable, document.getElementById("per_chassis_detailed_information_table_HEADERS"));
    clearTable(document.getElementById("health_table"), document.getElementById("health_table_HEADERS"));


    //Populate the Overall Cluster Status table...
    // Access the HTML table to be updated with this data.
    readAndStoreData("overallClusterInfo.csv", "overall_status_table_HEADERS", overallStatusTable);

  ////////////////////////////////////////
  ////////////////////////////////////////

    //Populate the Per Chassis Info table...
    // Access the HTML table to be updated with this data.
    readAndStoreData("perChassisInfo.csv", "per_chassis_detailed_information_table_HEADERS", perChassisTable);
    //var derivedClusterHealthStatus = populateTableFromCSVFile("per_chassis_detailed_information_table_HEADERS", perChassisTable);
    //Cluster Health Status data is derived from the per chassis data and is stored in a JSON object...
    //AND the health status table is populated when the chassis detailed information is complete...
  }

////////////////////////////////////////
////////////////////////////////////////


//   // Declare a variable to hold the contents of the CSV file in...
//   var csvFileOverallClusterStatus;
//
//   //For now, store the static path to the CSV file in a variable...
//   // Use XMLHttpRequest to read the contents of the data file and store them in variable csvFile.
//   var contentsOverallClusterStatus = new XMLHttpRequest();
//   contentsOverallClusterStatus.open("GET", "overallClusterInfo.csv", false);
//   contentsOverallClusterStatus.onreadystatechange = function ()
//   {
//      if(contentsOverallClusterStatus.readyState === 4 && (contentsOverallClusterStatus.status === 200 || contentsOverallClusterStatus.status == 0))
//      {
//              csvFileOverallClusterStatus = contentsOverallClusterStatus.responseText;
//      }
//   }
//   contentsOverallClusterStatus.send(null);
//
//   // Parse the data file by rows (newline character-delimited)...
//   // Store each row in an element of rows.
//   var rowsOverallClusterStatus = csvFileOverallClusterStatus.split("\n");
//
//   //Check if the file was refreshed by seeing if the value of the entire first row of the table is the same as in this file or not...
//   //Note that this line is a time stamp that is unique...
//   //initiliaze the prevFileID to that of the first file upload...
//   var prevFileID_OCS = rowsOverallClusterStatus[0]; //call this outside the function that checks if a new function and pass it in...return currentFileID
//
//   var currentFileID_OCS = rowsOverallClusterStatus[0];
//
//   //ERROR CHECK...
//   console.log(currentFileID_OCS);
//
//   if(currentFileID_OCS === prevFileID_OCS)
//   {
//     console.log("the data file has NOT been refreshed")
//   }
//   else {
//     console.log("the data file HAS been refreshed")
//     //update the data stamp at the top right of the page
//     //in later iterations, store the new file to the database (for backlog story on storing historical data)
//   }
//
//   //Populate the Overall Cluster Status table...
//   // Access the HTML table to be updated with this data.
//   var overallStatusTable = document.getElementById("overall_status_table");
//   populateTableFromCSVFile(rowsOverallClusterStatus, "overall_status_table_HEADERS", overallStatusTable);
//
//
// /////////////////////////////////////////////////////////////////////////////////
//   // Declare a variable to hold the contents of the CSV file in...
//   var csvFilePerChassis;
//
//   //For now, store the static path to the CSV file in a variable...
//   // Use XMLHttpRequest to read the contents of the data file and store them in variable csvFile.
//   var contentsPerChassis = new XMLHttpRequest();
//   contentsPerChassis.open("GET", "perChassisInfo.csv", false);
//   contentsPerChassis.onreadystatechange = function ()
//   {
//      if(contentsPerChassis.readyState === 4 && (contentsPerChassis.status === 200 || contentsPerChassis.status == 0))
//      {
//              csvFilePerChassis = contentsPerChassis.responseText;
//      }
//   }
//   contentsPerChassis.send(null);
//
//   // Parse the data file by rows (newline character-delimited)...
//   // Store each row in an element of rows.
//   var rowsPerChassis = csvFilePerChassis.split("\n");
//
//   //Check if the file was refreshed by seeing if the value of the entire first row of the table is the same as in this file or not...
//   //Note that this line is a time stamp that is unique...
//   //initiliaze the prevFileID to that of the first file upload...
//   var prevFileID_PC = rowsPerChassis[0]; //call this outside the function that checks if a new function and pass it in...return currentFileID
//
//   var currentFileID_PC = rowsPerChassis[0];
//
//   //ERROR CHECK...
//   console.log(currentFileID_PC);
//
//   if(currentFileID_PC === prevFileID_PC)
//   {
//     console.log("the per chassis data file has NOT been refreshed")
//   }
//   else {
//     console.log("the per chassis data file HAS been refreshed")
//     //update the data stamp at the top right of the page
//     //in later iterations, store the new file to the database (for backlog story on storing historical data)
//     //replace the contents of the data file here...
//   }


  // //Populate the Per Chassis Info table...
  // // Access the HTML table to be updated with this data.
  // var perChassisTable = document.getElementById("per_chassis_detailed_information_table");
  // var derivedClusterHealthStatus = populateTableFromCSVFile(rowsPerChassis, "per_chassis_detailed_information_table_HEADERS", perChassisTable);
  // //Cluster Health Status data is derived from the per chassis data and is stored in a JSON object...

////////////////////////////////////////////////////////////////////////////////

//   //Populate the Cluster Health Status table...
//   // Access the HTML table to be updated with this data.
//   var healthTable = document.getElementById("health_table");
//
// //  var healthData = JSON.parse(derivedClusterHealthStatus);
// //  console.log("HEALTH DATA: " + healthData);
//
// //IF THERE ARE MULTIPLE ROWS POSSIBLE IN THE CLUSTER HEALTH TABLE, THEN ADD IN THIS COMMENTED OUT LOOP AND CORRECT THE ENDING CONDITION...
// //  for(var r = 1; r < rowsRead.length-1; r++)
// //  {
//     //Populate the headers...
// //    if(r === 1)
// //    {
//     //Populate the headers.
//     for(var c = 0; c < Object.keys(derivedClusterHealthStatus).length; c++)
//     {
//       // Add element e to the current row in column c.
//       var newHeader = document.createElement("TH");
//       var newHeaderContent = document.createTextNode(Object.keys(derivedClusterHealthStatus)[c]);
//       newHeader.appendChild(newHeaderContent);
//       document.getElementById("health_table_HEADERS").appendChild(newHeader);
//     }
//
//     //Populate the rows.
//     console.log("WORKING ON HEALTH TABLE...");
//     // Add a row to the table.
//     //Reminder to self:If can add more rows in this table dynamically, then NEED to change insertRow(1) to insertRow(r) or (r-1)...
//     var newRow = healthTable.insertRow(1); //important: must index as r-1 since line 1 of file is line 0 in table, line 2 of file is line 1 of table, etc.
//
//     // Populate the newly created row...
//     // ***Note that (in a later iteration), the size of the table will need
//     // to potentially dynamically change to accommodate the longest data entry.***
//     for(var c = 0; c < Object.keys(derivedClusterHealthStatus).length; c++)
//     {
//       // Add element e to the current row in column c.
//       var cell = newRow.insertCell(c);
//       //cell.style.border = "initial"; //trying to add column delimiters in table
//       cell.innerHTML = derivedClusterHealthStatus[Object.keys(derivedClusterHealthStatus)[c]];
//     }
//  } //for loop if can have multiple rows in Cluster Health Status table

  // THE FOLLOWING COMMENTED OUT CODE (VIA ATOM'S TOGGLE COMMENT) WORKS - IT WAS SIMPLY MOVED TO
  // A FUNCTION TO AVOID DUPLICATION OF CODE...

  // Iterate through each column in the table and insert the values of the row in
  // that element...
  // Skip the first row as it is the unique ID associated with the file to check if file was refreshed.
  //   ***Note that it will be important to populate the headers of the table from the file
  // as well in order to allow for the data file/data population to be dynamic.***
  // //Populate the table.
  // for(var r = 1; r < rows.length-1; r++)
  // {
  //   //Populate the headers...
  //   if(r === 1)
  //   {
  //     //Dynamically insert the headers for the table according to the data file...
  //     // Parse this comma-delimited row...
  //     var headerRow = rows[r].split(",");
  //     console.log(headerRow);
  //     for(var c = 0; c < headerRow.length; c++)
  //     {
  //       // Add element e to the current row in column c.
  //       var newHeader = document.createElement("TH");
  //       var newHeaderContent = document.createTextNode(headerRow[c]);
  //       newHeader.appendChild(newHeaderContent);
  //       document.getElementById("overall_status_table_HEADERS").appendChild(newHeader);
  //     }
  //   }
  //   //Populate the non-header rows of the table...
  //   else {
  //     console.log("HERE");
  //     // Add a row to the table.
  //     var newRow = overallStatusTable.insertRow(r-1); //important: must index as r-1 since line 1 of file is line 0 in table, line 2 of file is line 1 of table, etc.
  //
  //     // Parse this comma-delimited row...
  //     var thisRow = rows[r].split(",");
  //
  //     //ERROR CHECK...
  //     console.log(thisRow);
  //
  //     // Populate the newly created row...
  //     // ***Note that (in a later iteration), the size of the table will need
  //     // to potentially dynamically change to accommodate the longest data entry.***
  //     for(var c = 0; c < thisRow.length; c++)
  //     {
  //       // Add element e to the current row in column c.
  //       var cell = newRow.insertCell(c);
  //       //cell.style.border = "initial"; //trying to add column delimiters in table
  //       cell.innerHTML = thisRow[c];
  //     }
  //   }
  // }

  //////////////////////////////////////////////////////////////////////////////
  // NOTES for future iterations/once I have access to the data file...
  // ***Note: We somehow need to show the lines between the columns...***
  // ***It may also be useful to erase the table and redraw it with each
  // reload of the table to avoid accidentally appending to it, etc.***

  //////////////////////////////////////////////////////////////////////////////
  // Questions that will be answered by sample data to be provided by the HPC Team:

  // Do we need to redraw the table each time read file?
  // Will we have one file or a file per table?

  // For overallStatusTable, okay to take the data straight from the file
  // each time it is needed...
  // Need to do this for other tables, as well, in case the data changes.
  // -OR-
  // Could have a flag to check to tell whether or not the data file was altered.
  // In this case, could store to a file and have an event triggered when the file
  // is refreshed (for example), saying the file has been altered...
  // Would also need a flag to tell if the file fails to exist.

  // In either case, would store the current data in a data structure in case some updated
  // error occurs (?), but likely best to read straight from file every time
  // to ensure the most up-to-date info...

var init;

  //The function that is called when the window is loaded...
  function start()
  {
    //Call the refresh function...
    refresh();
    init = 0;
  }

  window.onload = start;


</script>

<!-- end Riana's code -->
