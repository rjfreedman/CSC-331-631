<!DOCTYPE html>
<html lang = "en">
<head>
  <title> DEAC Cluster System Monitor </title>
  <!-- charset allows bootstrap characters -->
  <meta charset = "utf-8">
  <!-- viewport should allow bootstrap to resize for viewing device -->
  <meta name = "viewport" content = "width = device-width, initial-scale =1">
  <!-- Getting the bootstrap libraries for CSS from a CDN-->
  <!-- KR: Getting the bootstrap libraries for CSS from a CDN-->
  <!-- KR: add bootstrap for CSS, jquery and JavaScript -->
  <!-- 1) bootstrap for CSS: necessary for containers to provide responsive design -->
  <!-- 2,3) jquery and bootstrap for js, necessary for expansion buttons -->
  <link rel = "stylesheet" href = "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

  <!-- KG: needs these bootstrap and style for drop down menu check box functionality -->
  <link href="https://cdn-na.infragistics.com/igniteui/2016.2/latest/css/themes/infragistics/infragistics.theme.css" rel="stylesheet" />
    <link href="https://cdn-na.infragistics.com/igniteui/2016.2/latest/css/structure/infragistics.css" rel="stylesheet" />
    <!-- KR: modernizr allows it to run on old systems like IE7 -->
    <script src="https://ajax.aspnetcdn.com/ajax/modernizr/modernizr-2.8.3.js"></script>
    <!-- KR: removing this jquery because I needed 3.1.1 earlier
    <script src="https://code.jquery.com/jquery-1.11.3.min.js"></script> -->
    <script src="https://code.jquery.com/ui/1.11.1/jquery-ui.min.js"></script>

    <!-- KG: Ignite UI Required Combined JavaScript Files -->
    <script src="https://cdn-na.infragistics.com/igniteui/2016.2/latest/js/infragistics.core.js"></script>
    <script src="https://cdn-na.infragistics.com/igniteui/2016.2/latest/js/infragistics.lob.js"></script>

    <!-- HHL: Using google drive library for gauge graphics-->
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
   </script> -->

    <!--START Alexis code for health status infographic -->

      <!--Load the AJAX API-->
     <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
     <!-- <script type="text/javascript">

       // Load the Visualization API and the corechart package.
       //google.charts.load('current', {'packages':['corechart']});

       // Set a callback to run when the Google Visualization API is loaded.
       google.charts.setOnLoadCallback(drawPiChart);

       // Callback that creates and populates a data table,
       // instantiates the pie chart, passes in the data and
       // draws it.
       function drawPiChart() {

         // Create the data table.
         var pidata = new google.visualization.DataTable();
         pidata.addColumn('string', 'Node Status');
         pidata.addColumn('number', 'Nodes');
         pidata.addRows([
           ['Nodes Up', 256],
           ['Nodes Down', 16],
           ['Under Maintenance', 4]
         ]);

         // Set chart options
         var pioptions = {
                        'width':420,
                        'height':200};

         // Instantiate and draw our chart, passing in some options.
         var pichart = new google.visualization.PieChart(document.getElementById('piechart_div'));
         pichart.draw(pidata, pioptions);
       }
     </script> -->


   </script>

   <!--START Alexis code for health status infographic -->
     <!--Load the AJAX API-->
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script type="text/javascript">

      // Load the Visualization API and the corechart package.
      //google.charts.load('current', {'packages':['corechart']});

      // Set a callback to run when the Google Visualization API is loaded.
      google.charts.setOnLoadCallback(drawPiChart);

      // Callback that creates and populates a data table,
      // instantiates the pie chart, passes in the data and
      // draws it.
      function drawPiChart() {

        // Create the data table.
        var pidata = new google.visualization.DataTable();
        pidata.addColumn('string', 'Node Status');
        pidata.addColumn('number', 'Nodes');
        pidata.addRows([
          ['Nodes Up', 256],
          ['Nodes Down', 16],
          ['Under Maintenance', 4]
        ]);

        // Set chart options
        var pioptions = {
                       'width':420,
                       'height':200};

        // Instantiate and draw our chart, passing in some options.
        var pichart = new google.visualization.PieChart(document.getElementById('pichart_div'));
        pichart.draw(pidata, pioptions);
      }
    </script>

    <!--END Alexis code for health status infographic -->

    <style>
            .combo-label {margin-bottom:.5em; align-items:right; }
    </style>
    <!-- Lee's table style currently styling ALL tables on page -->
    <!-- Riana: added the text-align: center specification when populating the data for readability -->
    <style>
            table, tr, th{
                border: 1px solid black;
                border-collapse: collapse;
                text-align: center;
            }
            tr, th{
                padding: 5px
            }
        </style>


</head>
<body>
  <!-- adding containers to ensure the page resizes well on different devices -->
<div class="container-fluid">
  <div class = "row">
    <!-- KR: This is the top of the page, small container at each side for logo/update info, large box in middle for title -->
    <div class="col-sm-2"><p id="logo">logo?</p> </div>
    <div class="col-sm-8"><h1 id="pageTitle" align="center">DEAC Cluster System Monitor</h1></div>
    <div class="col-sm-2">
      <!-- KR: divs for current time and last update time JS fills current, need to add last update time functionality-->
      <p id="currentDateTime"></p>
      <script>
	document.getElementById("currentDateTime").innerHTML=Date()
      </script>
      <!-- Riana: added a line and adjusted the IDs so that the timestamp can dynamically be placed in .innerHTML via javascript -->
      <p id="lastUpdateDateTimeStatic">Site last updated:</p>
      <p id="lastUpdateDateTime"></p>
      <!-- Riana: added this button for refreshing purposes (per discussion with Dr. Pauca) -->
      <button class="btn" onclick="refresh()">Refresh</button><br><br>
      <!-- Riana: added this line of information as note regarding refresh -->
      <p><i>*Please Note:<br>Data is updated hourly.</i></p><br>

    </div>
  </div>

<!-- Riana: I changed all div classes to "col-sm-3" to have a row of 4 items in the initial view... -->
  <div class="row" id="initialView">
    <!-- KR: All columns equal, change col-sm-* to change this, all must add to 12 -->
    <!-- KR: Currently all containers in this row (3) set to align="center" change as appropriate later. -->
    <!--<div class="col-sm-4" id="clusterStatusFirstView" align="center">-->
    <div class="col-sm-3" id="clusterStatusFirstView" align="center">
      <!-- KR: put clusterStatusInfographis in the following <figure></figure> -->
     <div id="chart_div" style="font-size: 15px"></div>
      <!-- KR: collapsible button to expand statusTable div -->
      <button class="btn btn-primary" data-toggle="collapse" data-target="#statusTable">
	More Cluster Status Information
      </button>
    </div>

  <!--<div class="col-sm-4" id="clusterHealthFirstView" align="center"> -->
  <div class="col-sm-3" id="clusterHealthFirstView" align="center">
    <!-- KR: put clusterHealthInfographic in the following <figure></figure> -->
    <div id="pichart_div"></div>
    <!-- KR: collapsible button to expand healthTable div -->
    <button class="btn btn-primary" data-toggle="collapse" data-target="#healthTable" aria-expanded="false" aria-controls="healthTable">
      More Cluster Health Information
    </button>
  </div>

<!-- Begin Riana's addition for node utilization status table -->
  <div class="col-sm-3" id="nodeUtilizationStatusFirstView" align="center">
    <!-- Replace the id in the next line when ready... -->
    <div id="node_utilization_div"></div>
    <button class="btn btn-primary" data-toggle="collapse" data-target="#nodeUtilizationTable" aria-expanded="false" aria-controls="nodeUtilizationTable">
      Expand Node Utilization Information
    </button>
  </div>
<!-- End Riana's addition for node utilization status table -->

  <!--<div class="col-sm-4" id="perChassisAccessPoint" align="center"> -->
  <div class="col-sm-3" id="perChassisAccessPoint" align="center">
    <!-- KR: collapsible button to expand healthTable div -->
    <button class="btn btn-primary" data-toggle="collapse" data-target="#chassisInfo" aria-expanded="false" aria-controls="chassisInfo">
      Detailed Information for Each Chassis
    </button>
  </div>
</div> <!-- end 3 column responsive row -->

<!-- KR: following divs must have class="Collapse" so that collapse buttons work -->
<div class="collapse" id="statusTable">
  <!-- Status Table by Lee -->
  <!-- KR: br adds vertical space before the table, play with these to achieve optimal spacing -->
  <br></br>
  <br></br>
  <table id="overall_status_table">
    <h4 class="combo-label">Overall Cluster Status</h4>
    <!-- Riana: added an id for the headers so they can be autopopulated from the CSV file -->
    <tr id="overall_status_table_HEADERS">
      <!-- Riana: commented out all table headers in order to auto-populate them -->
      <!-- <th>Running Jobs</th>
      <th>Queued Jobs</th>
      <th>Number of CPUs</th> -->
    </tr>
  </table>
</div>

<div class="collapse" id="healthTable">
  <br></br>
  <br></br>
<!-- Health Status Table by AA -->
	<table id="health_table">
	  <h4 class="combo-label">Cluster Health Status</h4>
    <!-- Riana: added an id for the headers so they can be autopopulated from the CSV file -->
		<tr id= "health_table_HEADERS">
      <!-- Riana: commented out all table headers in order to auto-populate them. -->
			<!-- <th>Number of Nodes Up</th>
			<th>Number of Nodes Down</th>
			<th>Number of Nodes Under Maintenance</th> -->
		</tr>

	</table>

</div>

<!-- Begin Riana's addition of the node utilization status table -->
<div class="collapse" id="nodeUtilizationTable">
  <br></br>
  <br></br>
	<table id="node_utilization_table">
	  <h4 class="combo-label">Node Utilization Status</h4>
		<tr id= "node_utilization_table_HEADERS">
      <!-- Column headers will be filled in dynamically according to file... -->
		</tr>
	</table>
</div>
<!-- End Riana's addition of the node utilization status table -->

<!-- KG: Chassis Information table and drop down -->
<div class="collapse" id="chassisInfo">
  <br></br>
        <br></br>
    <h4 class="combo-label">Single/Multiple Selection of Chasses with Checkboxes</h4>
    <div id="checkboxSelectCombo" ></div>
    <!-- submit button for per chasiss detailed information-->
    <input type="button" name="Submit Chassis" value="Submit single/multiple Chassis" onclick="return getSelectedOptions();" >
    <br> </br>

    <!-- Riana: commented out this code and moved the necessary information to the script below so that the data will be accessible and
        can then populate the HTML component via the ID assigned to the dropdown menu -->

    <!-- <script type="text/javascript">
        //Riana: commented out contents of this array to work on auto-population and fixed the spelling of chassis
        //Riana: to note - do not need objects here - just list the chassis names as strings and comma-separate the different chassis names in the array...
        //var chassis = [
            // { Name: "Chassis 1" },
            // { Name: "Chassis 2" },
            // { Name: "Chassis 3" },
            // { Name: "Chassis 4" }
        //];
        // $(function () {
        //     $("#checkboxSelectCombo").igCombo({
        //         width: "270px",
        //         dataSource: window.chassisNames, //Riana: fixed the spelling of chassis
        //         textKey: "Name",
        //         valueKey: "Name",
        //         multiSelection: {
        //             enabled: true,
        //             showCheckboxes: true
        //         }
        //     });
        // });
    </script> -->

  <!--Riana: fixed the spelling on chassis in the table id and added an id for the headers so they can be autopopulated from the CSV file -->
  <table id="per_chassis_detailed_information_table">
      <tr id="per_chassis_detailed_information_table_HEADERS">
        <!-- Riana: commented out all table headers in order to auto-populate them -->
          <!-- <th>Chassis</th>
          <th>Utilization</th>
          <th>Number of CPUs Available</th>
          <th>Total Number of CPUs</th>
          <th>Memory Utilization</th> -->
      </tr>
  </table>
</div> <!-- end chassisInfo div -->

<!--Riana: added a space below the last table in order to be able to see the data in the last row of the table clearly -->
<br>

</body>
</html>



<!-- start Riana's code -->

<script>

  //Declare variables needed throughout this script...
  var prevFileID;
  var currentFileID;

  //Define a variable to be used throughout this script as a means of checking whether the initial data read has been completed (for comparison purposes).
  var init;

  //Access the tables directly associated with data reported in the CSV files.
  var overallStatusTable = document.getElementById("overall_status_table");
  var perChassisTable = document.getElementById("per_chassis_detailed_information_table");

  //Indicate that a filter is currently in place such that the data should be refreshed with the per chassis table re-drawn only displaying the filtered rows...
  var filterDropdownObserved;
  var filterClickObserved;
  var filterContent;

  //FOR INFOGRAPHICS
  google.charts.load('current', {'packages':['gauge', 'corechart']});

  //BEGIN CODE FOR OVERALL STATUS INFOGRAPHIC
  var numberOfCPUsConsumed;
  var totalNumberOfCPUs;

  var fractionOfCPUsConsumed;

  function drawChart() {
    var data = google.visualization.arrayToDataTable([
      ['Label', 'Value'],
      ['Overall Status', fractionOfCPUsConsumed],
    ]);
    var options = {
      width: 420, height: 200,
      redFrom: 90, redTo: 100,
      yellowFrom:75, yellowTo: 90,
      minorTicks: 5
    };
    var chart = new google.visualization.Gauge(document.getElementById('chart_div'));
    chart.draw(data, options);
    setInterval(function() {
      data.setValue(fractionOfCPUsConsumed);
      chart.draw(data, options);
    }, 13000);
  }

  //END CODE FOR OVERALL STATUS INFOGRAPHIC


  //BEGIN CODE FOR HEALTH STATUS INFOGRAPHIC

  // Load the Visualization API and the corechart package.
  //google.charts.load('current', {'packages':['corechart']});

  // Callback that creates and populates a data table,
  // instantiates the pie chart, passes in the data and
  // draws it.
  var numberOfNodesUP;
  var numberOfNodesDOWN;
  var numberOfNodesUNDERMAINTENANCE;

  function drawPiChart() {

    // Create the data table.
    var pidata = new google.visualization.DataTable();
    pidata.addColumn('string', 'Node Status');
    pidata.addColumn('number', 'Nodes');
    pidata.addRows([
      ['Nodes Up', numberOfNodesUP],
      ['Nodes Down', numberOfNodesDOWN],
      ['Under Maintenance', numberOfNodesUNDERMAINTENANCE]
    ]);

    // Set chart options
    var pioptions = {
                   'width':420,
                   'height':200};

    // Instantiate and draw our chart, passing in some options.
    var pichart = new google.visualization.PieChart(document.getElementById('piechart_div'));
    pichart.draw(pidata, pioptions);
  }

  //END CODE FOR HEALTH STATUS INFOGRAPHIC

  //BEGIN CODE FOR NODE UTILIZATION STATUS INFOGRAPHIC

  var fractionOfNodesAllocated;

  function drawAllocatedChart(){
      var allocatedData=google.visualization.arrayToDataTable([
          ['Label','Value'],
          ['Allocation', fractionOfNodesAllocated],
      ]);
      var allocatedOptions = {
                 width: 420, height: 200,
                 redFrom: 90, redTo: 100,
                 yellowFrom:75, yellowTo: 90,
                 minorTicks: 5
           };
           var allocatedChart = new google.visualization.Gauge(document.getElementById('node_utilization_div'));
           allocatedChart.draw(allocatedData, allocatedOptions);
          //  setInterval(function() {
          //    allocatedData.setValue(fractionOfCPUsConsumed);
          //    chart.draw(allocatedData, allocatedOptions);
          //  }, 13000);
  }

  //END CODE FOR NODE UTILIZATION STATUS INFOGRAPHIC


  //Place all code for populating a data file from a header in a function
  //  to avoid duplication of code...
  function populateTableFromCSVFile(rowsRead, headerID, rowID, rowsToDisplay, filterON, filterViaOtherTable)
  {
    //Store information about the current filter in the event that the refresh button is clicked...
    if(headerID === "per_chassis_detailed_information_table_HEADERS")
    {
      filterDropdownObserved = filterON;
      filterClickObserved = filterViaOtherTable;
      filterContent = rowsToDisplay;
    }

    // Iterate through each column in the table and insert the values of the row in
    // that element...
    // Skip the first row as it is the unique ID associated with the file to check if file was refreshed.
    // ***Note that it will be important to populate the headers of the table from the file
    // as well in order to allow for the data file/data population to be dynamic.***

    //The following variables will assist in deriving the Cluster health data from the per chassis info.
    //Initialize indices to invalid values...
    var indexNodesUP = -1;
    var indexNodesDOWN = -1;
    var indexNodesUNDERMAINTENANCE = -1;
    numberOfNodesUP = 0;
    numberOfNodesDOWN = 0;
    numberOfNodesUNDERMAINTENANCE = 0;

    //The following variables will assist in deriving the Node Utilization Status data from the per chassis info.
    //Initialize indices to invalid values...
    var indexNodesIdle = -1;
    var indexNodesMixed = -1;
    var indexNodesAllocated = -1;
    var numberOfNodesIdle = 0;
    var numberOfNodesMixed = 0;
    var numberOfNodesAllocated = 0;

    //The following variables will assist in deriving the information required to fill in the data of the Overall Cluster Status infographic.
    var indexNumberOfCPUsConsumed = -1;
    var indexTotalNumberOfCPUs = -1;
    totalNumberOfCPUs = 0;

    //The following variables will assist in auto-populating the dropdown menu for filtering the per chassis info by chassis name.
    //Initiliaze index to an invalid value...
    var indexChassisNames = -1;
    var chassisNames = []; //no names collected yet; thus, initialize to an empty array
                           //(also - create and initialize variable here so the refresh will clear the array before re-populating)
    var rowsToAdd = 0; //keep track of the row index that should be added to the table next (for use when filtering)

    //For filtering based on column content (if filterViaOtherTable === true)...
    //Initiliaze index to an invalid value...
    var specifiedColumnIndex = -1;

    //Populate the table indicated by the input parameters to this function.
    for(var r = 1; r < rowsRead.length-1; r++)
    {
      //Populate the headers...
      if(r === 1)
      {
        //Dynamically insert the headers for the table according to the data file...
        //Parse this comma-delimited row...
        var headerRow = rowsRead[r].split(",");
        console.log(headerRow);
        for(var c = 0; c < headerRow.length; c++)
        {
          // Add an element to the current row in column c.
          var newHeader = document.createElement("th");
          var newHeaderContent = document.createTextNode(headerRow[c]);
          newHeader.appendChild(newHeaderContent);
          document.getElementById(headerID).appendChild(newHeader);

          //IF this is the Overall Cluster Status information - gather data dynamically...
          if(headerID === "overall_status_table_HEADERS")
          {
            if(headerRow[c].includes("Number of CPUs"))
            {
              indexNumberOfCPUsConsumed = c;
            }
          }

          //IF this is the Per Chassis info - gather data for the Cluster Health Status table dynamically...
          //MUST use [STRING].includes("String to compare against") here since white space will affect the result...
          if(headerID === "per_chassis_detailed_information_table_HEADERS")
          {
            //If the table is to be filtered to display only rows containing a value greater than zero in the selected column, determine the column to be addressed...
            //  Store its index in a variable.
            if(filterViaOtherTable && headerRow[c].includes(rowsToDisplay))
            {
              specifiedColumnIndex = c;
            }

            //If the current header is any of the categories indicated in Cluster Health Status OR in Node Utilization Status OR
            //  for auto-population of the Chassis Names dropdown menu,
            //  then mark this column accordingly for data collection when populating the rows of the table...

            if(headerRow[c].includes("Number of Nodes UP"))
            {
              indexNodesUP = c;
            }
            else if(headerRow[c].includes("Number of Nodes DOWN"))
            {
              indexNodesDOWN = c;
            }
            else if(headerRow[c].includes("Number of Nodes UNDER MAINTENANCE"))
            {
              indexNodesUNDERMAINTENANCE = c;
            }
            else if(headerRow[c].includes("Number of Nodes Idle"))
            {
              indexNodesIdle = c;
            }
            else if(headerRow[c].includes("Number of Nodes Mixed"))
            {
              indexNodesMixed = c;
            }
            else if(headerRow[c].includes("Number of Nodes Allocated"))
            {
              indexNodesAllocated = c;
            }
            else if(headerRow[c].includes("Chassis Name"))
            {
              indexChassisNames = c;
            }
            else if(headerRow[c].includes("Total Number of CPUs"))
            {
              indexTotalNumberOfCPUs = c;
            }

          }
        }
      }
      else { //Populate the non-header rows of the table...

        // Parse this comma-delimited row...
        var thisRow = rowsRead[r].split(",");

        //IF dealing with the per chassis table...
        if(headerID === "per_chassis_detailed_information_table_HEADERS")
        {
          //Refresh the data from this row AND display the row in the per chassis table IF:
          //  the rows are to be filtered AND this row was selected AND this is not filtered by column content
          //  OR
          //  the rows are to be filtered AND they are to be filtered by their contribution to a selected column AND this row's value in the selected column is > 0
          //  OR
          //  the rows are NOT to be filtered (ie. all rows should be displayed)
          if((filterON && rowsToDisplay.includes(thisRow[indexChassisNames]) && filterViaOtherTable === false) || (filterON && filterViaOtherTable && (thisRow[specifiedColumnIndex] > 0)) || (filterON === false))
          {
            // Add a row to the table.
            rowsToAdd = rowsToAdd + 1; //increment the index that the row should be added to
            var newRow = rowID.insertRow(rowsToAdd);

            // Populate the newly created row...
            // ***Note that (in a later iteration), the size of the table will need
            // to potentially dynamically change to accommodate the longest data entry.***
            for(var c = 0; c < thisRow.length; c++)
            {
              // Add a cell to the current row in column c.
              var cell = newRow.insertCell(c);

              //Store the data in the new cell.
              cell.innerHTML = thisRow[c];

              //Add (the numerical equivalent of) the number of nodes UP, DOWN, or UNDER MAINTENANCE to the running sum
              //  if the current column represents one of these categories.

              if(c === indexNodesUP)
              {
                numberOfNodesUP += parseInt(thisRow[c]);
              }
              if(c === indexNodesDOWN)
              {
                //console.log("DOWN"); //error check
                numberOfNodesDOWN += parseInt(thisRow[c]);
              }
              if(c === indexNodesUNDERMAINTENANCE)
              {
                //console.log("UM"); //error check
                numberOfNodesUNDERMAINTENANCE += parseInt(thisRow[c]);
              }

              //Add (the numerical equivalent of) the number of nodes idle, mixed, or allocated to the running sum
              //  if the current column represents one of these categories.
              if(c === indexNodesIdle)
              {
                numberOfNodesIdle += parseInt(thisRow[c]);
              }
              if(c === indexNodesMixed)
              {
                numberOfNodesMixed += parseInt(thisRow[c]);
              }
              if(c === indexNodesAllocated)
              {
                numberOfNodesAllocated += parseInt(thisRow[c]);
              }

              //Add (the numberical equivalent of) the number of CPUs total for the Overall Cluster Status infographic.
              if(c === indexTotalNumberOfCPUs)
              {
                totalNumberOfCPUs += parseInt(thisRow[c]);
              }

              //Assemble the list of chassis names to be used to auto-populate the dropdown menu
              //  if the current column represents a chassis name.
              if(c === indexChassisNames)
              {
                chassisNames.push(thisRow[c]);
              }
            }
          }
          else //filter is ON and this row was NOT selected - thus, refresh all data but do not display this row in the per chassis info table...
          {
            // Populate the newly created row...
            // ***Note that (in a later iteration), the size of the table will need
            // to potentially dynamically change to accommodate the longest data entry.***
            for(var c = 0; c < thisRow.length; c++)
            {
              //Add (the numerical equivalent of) the number of nodes UP, DOWN, or UNDER MAINTENANCE to the running sum
              //  if the current column represents one of these categories.

              if(c === indexNodesUP)
              {
                numberOfNodesUP += parseInt(thisRow[c]);
              }
              if(c === indexNodesDOWN)
              {
                //console.log("DOWN"); //error check
                numberOfNodesDOWN += parseInt(thisRow[c]);
              }
              if(c === indexNodesUNDERMAINTENANCE)
              {
                //console.log("UM"); //error check
                numberOfNodesUNDERMAINTENANCE += parseInt(thisRow[c]);
              }

              //Add (the numerical equivalent of) the number of nodes idle, mixed, or allocated to the running sum
              //  if the current column represents one of these categories.
              if(c === indexNodesIdle)
              {
                numberOfNodesIdle += parseInt(thisRow[c]);
              }
              if(c === indexNodesMixed)
              {
                numberOfNodesMixed += parseInt(thisRow[c]);
              }
              if(c === indexNodesAllocated)
              {
                numberOfNodesAllocated += parseInt(thisRow[c]);
              }

              //Add (the numberical equivalent of) the number of CPUs total for the Overall Cluster Status infographic.
              if(c === indexTotalNumberOfCPUs)
              {
                totalNumberOfCPUs += parseInt(thisRow[c]);
              }

              //Assemble the list of chassis names to be used to auto-populate the dropdown menu
              //  if the current column represents a chassis name.
              if(c === indexChassisNames)
              {
                chassisNames.push(thisRow[c]);
              }
            } //end for(... c < thisRow.length ...)
          }
        } //end if(headerID === "per_chassis_detailed_information_table_HEADERS")
        else //if dealing with a table OTHER than the per chassis table, do not handle filters...
        {
          var newRow = rowID.insertRow(r-1); //important: must index as r-1 since line 1 of file is line 0 in table, line 2 of file is line 1 of table, etc.

          // Parse this comma-delimited row...
          var thisRow = rowsRead[r].split(",");

          // Populate the newly created row...
          // ***Note that (in a later iteration), the size of the table will need
          // to potentially dynamically change to accommodate the longest data entry.***
          for(var c = 0; c < thisRow.length; c++)
          {
            // Add a cell to the current row in column c.
            var cell = newRow.insertCell(c);

            //Store the data in the new cell.
            cell.innerHTML = thisRow[c];

            if(headerID === "overall_status_table_HEADERS")
            {
              console.log("HERE in overall table" + thisRow[c]);
              if(c === indexNumberOfCPUsConsumed)
              {
                numberOfCPUsConsumed = thisRow[c];
              }
            }
          }
        } //end else associated with if(headerID === "per_chassis_detailed_information_table_HEADERS")
      } //end for(... r < rowsRead.length-1 ...)
    }

    //IF this is the Per Chassis info - gather data for the Cluster Health Status table dynamically...
    if(headerID === "per_chassis_detailed_information_table_HEADERS")
    {
      //Data collection complete...

      //Check for ERRORs in data collection.
      if(indexNodesUP === -1) {
        numberOfNodesUP = "ERROR";
      }
      if(indexNodesDOWN === -1) {
        numberOfNodesDOWN = "ERROR";
      }
      if(indexNodesUNDERMAINTENANCE === -1) {
        numberOfNodesUNDERMAINTENANCE = "ERROR";
      }
      if(indexNodesIdle === -1) {
        numberOfNodesIdle = "ERROR";
      }
      if(indexNodesMixed === -1) {
        numberOfNodesMixed = "ERROR";
      }
      if(indexNodesAllocated === -1) {
        numberOfNodesAllocated = "ERROR";
      }
      if(indexTotalNumberOfCPUs === -1) {
        totalNumberOfCPUs = "ERROR";
      }

      //Do nothing if an empty array of chassis names (as the dropdown menu above will handle this)...

      //Create a JSON object containing the data for the Cluster Health Status table.
      var jsonDerivedClusterHealth = {
        "Number of Nodes UP": numberOfNodesUP,
        "Number of Nodes DOWN": numberOfNodesDOWN,
        "Number of Nodes UNDER MAINTENANCE": numberOfNodesUNDERMAINTENANCE
      };

      //Create a JSON object containing the data for the Node Utilization Status table.
      var jsonDerivedNodeUtilization = {
        "Number of Nodes Idle": numberOfNodesIdle,
        "Number of Nodes Mixed": numberOfNodesMixed,
        "Number of Nodes Allocated": numberOfNodesAllocated
      };

      //Call the function to populate the Cluster Health Status table.
      //Call this function here to avoid a race condition since javascript functions are non-blocking...
      populateDerivedTable(jsonDerivedClusterHealth, "health_table", "health_table_HEADERS");

      //Call the function to populate the Node Utilization Status table.
      //Call this function here to avoid a race condition since javascript functions are non-blocking...
      populateDerivedTable(jsonDerivedNodeUtilization, "node_utilization_table", "node_utilization_table_HEADERS");

      //FOR OVERALL CLUSTER STATUS
      fractionOfCPUsConsumed = (numberOfCPUsConsumed / totalNumberOfCPUs) * 100;
      console.log("FRACTION: " + fractionOfCPUsConsumed);
      console.log("DIVISION: " + numberOfCPUsConsumed + " " + totalNumberOfCPUs);
      google.charts.setOnLoadCallback(drawChart);

      //FOR CLUSTER HEALTH STATUS INFOGRAPHIC
      // Set a callback to run when the Google Visualization API is loaded.
      google.charts.setOnLoadCallback(drawPiChart);

      //For Node Utilization Status table
      fractionOfNodesAllocated = (numberOfNodesAllocated / (numberOfNodesIdle + numberOfNodesMixed + numberOfNodesAllocated)) * 100;
      google.charts.setOnLoadCallback(drawAllocatedChart);
    }
    //else { //do nothing...
    //  return "NO CLUSTER HEALTH DATA IS DERIVED FROM THIS FILE.";
    //}

    //Populate the dropdown menu dynamically...
    //Note that I copied and pasted Kanika's JQuery code here so that the chassisNames variable will be accessible...
    //Since the ID for the dropdown menu created in HTML is accessible, the dropdown menu can be populated here...
    $(function () {
        $("#checkboxSelectCombo").igCombo({
            width: "270px",
            dataSource: chassisNames, //Riana: fixed the spelling of chassis
            textKey: "Name",
            valueKey: "Name",
            multiSelection: {
                enabled: true,
                showCheckboxes: true
            }
        });
    });

  }



  //Define a function to access, open, and read a CSV data file.
  //Store the contents extracted from the file in a variable.
  //Place all of this code in a function to avoid duplication of code.
  function readAndStoreData(fileName, idTableHeaders, idTableRows, rowsToDisplay, filterON, filterViaOtherTable)
  {
    // Declare a variable to hold the contents of the CSV file in...
    var csvFile = "";

    //Use XMLHttpRequest to read the contents of the data file and store them in variable csvFile.
    var contents = new XMLHttpRequest();
    contents.open("GET", fileName, false);
    contents.onreadystatechange = function ()
    {
       if(contents.readyState === 4 && (contents.status === 200 || contents.status == 0))
       {
               csvFile = contents.responseText;
       }
    }
    contents.send(null);

    //Parse the data file by rows (newline character-delimited)...
    //Store each row in an element of rows.
    var rows = csvFile.split("\n");

    //Check if the file was refreshed by seeing if the value of the entire first row of the table is the same as in this file or not...
    //Note that this line is a time stamp that is unique...
    //Initiliaze the prevFileID to that of the first file upload when the page is loaded...
    if(init === 0)
    {
      prevFileID = rows[0];
      init = 1; //indicate that initialization is now complete
      document.getElementById("lastUpdateDateTime").innerHTML = prevFileID;
    }

    //Store the current unique ID in the appropriate variable for comparison.
    currentFileID = rows[0];

    //ERROR CHECK...
    console.log(currentFileID);

    if(currentFileID === prevFileID)
    {
      //Error check...
      console.log("The data file has NOT been refreshed.")
    }
    else
    {
      //ERROR CHECK...
      console.log("The data file HAS been refreshed.")

      //Update the data stamp at the top right of the page.
      document.getElementById("lastUpdateDateTime").innerHTML = currentFileID;

      //Update the previous file refresh unique ID for comparison when the next refresh is requested/occurs.
      prevFileID = currentFileID;

      //In a later iterations, store the new file to the database here (for backlog story on storing historical data).
    }

    //Call the appropriate function to populate the data table associated with this data file.
    //Call this function here to avoid a race condition since javascript functions are non-blocking...
    populateTableFromCSVFile(rows, idTableHeaders, idTableRows, rowsToDisplay, filterON, filterViaOtherTable);
  }



  //Define a function to populate the Cluster Health Status table with the data derived from the per chassis info.
  //The data needed to populate this table is stored in a JSON object, passed into this function as an input parameter.
  function populateDerivedTable(derivedStatusInfo, tableID, tableHeadersID)
  {
    //Access the HTML table to be updated with this data.
    var theTable = document.getElementById(tableID);

    //Populate the headers.
    for(var c = 0; c < Object.keys(derivedStatusInfo).length; c++)
    {
      // Add an element to the current row in column c.
      var newHeader = document.createElement("TH");
      var newHeaderContent = document.createTextNode(Object.keys(derivedStatusInfo)[c]);

      //For the Cluster Health Status and Node Utilization Status tables:
      //  when the column header is clicked, filter by the information in these columns (ie. display only if a chassis made a contribution to the selected total)...
      newHeader.onclick = function(){
        filterByContributorsToThisColumn(this.innerHTML); //send the column header's text as the specification for the rows to be filtered by
        console.log("FILTERING BY THIS ROW..."); //error check
      };

      newHeader.appendChild(newHeaderContent);
      document.getElementById(tableHeadersID).appendChild(newHeader);
    }

    //ERROR CHECK...
    console.log("WORKING ON A DERIVED TABLE...");

    //Populate the rows...

    //Add a row to the table.
    //Reminder to self: If can add more rows in this table dynamically, then NEED to change insertRow(1) to insertRow(r) or (r-1)...
    var newRow = theTable.insertRow(1);

    // Populate the newly created row...
    // ***Note that (in a later iteration), the size of the table will need
    // to potentially dynamically change to accommodate the longest data entry.***
    for(var c = 0; c < Object.keys(derivedStatusInfo).length; c++)
    {
      // Add a cell to the current row in column c.
      var cell = newRow.insertCell(c);
      cell.innerHTML = derivedStatusInfo[Object.keys(derivedStatusInfo)[c]];
    }
  }

  ////////////////////////////////////////
  ////////////////////////////////////////

  //Declare a function that will clear a table's rows and headers.
  //This is needed to prevent the refresh of data from appending to the current tables.
  function clearTable(table, tableHeaders) {

    //Delete each row from the bottom up until the top, except for row 0 (the header row).
    var numRows = table.getElementsByTagName("tr").length;
    for(i = numRows - 1; i > 0; i--){
      table.deleteRow(i);
    }

    //Delete the header row.
    var numHeaders = tableHeaders.getElementsByTagName("TH").length;
    for(i = numHeaders - 1; i >= 0; i--){
      tableHeaders.deleteCell(i);
    }
  }

  //Define a function that will be called to refresh the data.
  //A refresh can occur on page load OR on pressing the refresh button.
  function refresh()
  {
    //FIRST - clear the tables to be sure the refreshed data is NOT accidentally appended to the existing table...
    clearTable(overallStatusTable, document.getElementById("overall_status_table_HEADERS"));
    clearTable(perChassisTable, document.getElementById("per_chassis_detailed_information_table_HEADERS"));
    clearTable(document.getElementById("health_table"), document.getElementById("health_table_HEADERS"));
    clearTable(document.getElementById("node_utilization_table"), document.getElementById("node_utilization_table_HEADERS"));

    //Populate the Overall Cluster Status table...
    readAndStoreData("overallClusterInfo.csv", "overall_status_table_HEADERS", overallStatusTable, filterContent, filterDropdownObserved, filterClickObserved);

    //Populate the Per Chassis Info table...
    readAndStoreData("perChassisInfo.csv", "per_chassis_detailed_information_table_HEADERS", perChassisTable, filterContent, filterDropdownObserved, filterClickObserved);
    //Cluster Health Status data is derived from the per chassis data and is stored in a JSON object...
    //AND the health status table is populated when the chassis detailed information is complete...

    //FOR TESTING PURPOSES ONLY...
    //filterPerChassisTableByDropdown(["bc01", "bc02", "a1a3"]);
  }

  //Define a function that will filter the table containing per chassis information to display only the rows containing the
  //  chassis name(s) specified in the array passed in as a parameter.
  //This function should be called when the SUBMIT button is clicked.
  function filterPerChassisTableByDropdown(rowsToDisplay)
  {
    //FIRST - clear the tables...
    clearTable(perChassisTable, document.getElementById("per_chassis_detailed_information_table_HEADERS"));
    clearTable(document.getElementById("health_table"), document.getElementById("health_table_HEADERS"));
    clearTable(document.getElementById("node_utilization_table"), document.getElementById("node_utilization_table_HEADERS"));

    //Now populate the table without re-creating the JSON objects for the overall table AND only displaying the selected rows
    //  AND with the most up-to-date information...
    //  Note that the filterON parameter of the function indicates that an array with chassis names to filter by is provided...
    readAndStoreData("perChassisInfo.csv", "per_chassis_detailed_information_table_HEADERS", perChassisTable, rowsToDisplay, true, false);
  }

  //Define a function that will filter the per chassis table by contributors to the column clicked on
  //  (ie. rows whose value in that column is greater than 0).
  function filterByContributorsToThisColumn(rowsToDisplay)
  {
    //FIRST - clear the tables...
    clearTable(perChassisTable, document.getElementById("per_chassis_detailed_information_table_HEADERS"));
    clearTable(document.getElementById("health_table"), document.getElementById("health_table_HEADERS"));
    clearTable(document.getElementById("node_utilization_table"), document.getElementById("node_utilization_table_HEADERS"));

    //Now populate the table without re-creating the JSON objects for the overall table AND only displaying the selected rows
    //  AND with the most up-to-date information...
    //  Note that the filterON parameter of the function indicates that an array with the column to filter by is provided...
    //  Note that the filterViaOtherTable parameter of the function indicates that a column header in another table was selected to filter the data by...
    readAndStoreData("perChassisInfo.csv", "per_chassis_detailed_information_table_HEADERS", perChassisTable, rowsToDisplay, true, true);

    console.log(rowsToDisplay); //error check
  }

  //Define the function that is called when the window is loaded...
  function start()
  {
    //Indicate that the initial data read has not been completed yet.
    init = 0;

    //Initialize the variables for data refresh to reflect that no filter is in place...
    filterDropdownObserved = false;
    filterClickObserved = false;
    filterContent = [];

    //Call the refresh function...
    refresh();
  }

  //On page load, call the start() function...
  window.onload = start;

</script>

<!-- end Riana's code -->
